<pre class='metadata'>
Title: Using Enum
Status: P
Audience: SG1, EWG
Editor: Gašper Ažman <gasper.azman@gmail.com>
Editor: Jonathan Müller <jonathan.mueller@foonathan.net>
Shortname: P1099
Abstract: Class enums are restricted namespaces. Let's extend the using
          declaration to them.
Group: WG21
Date: 2018-09-01
Markup Shorthands: markdown yes
Revision: 2
ED: https://github.com/atomgalaxy/using-enum/using-enum.bs
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

Revision History {#history}
================
- r1: Typos. Changed target from LEWG to EWG.
- r2: Added FAQ and wording, and extended to regular enums.

Motivation {#motivation}
==========

> The single biggest deterrent to use of scoped enumerations is the inability to associate them with a *using directive*.
>
>     -- Dan Saks

Consider an enum class:

```cpp
enum class rgba_color_channel { red, green, blue, alpha };
```

Currently, a switch using this enum looks as follows:

```cpp
std::string_view to_string(rgba_color_channel channel) {
  switch (channel) {
    case rgba_color_channel::red:   return "red";
    case rgba_color_channel::green: return "green";
    case rgba_color_channel::blue:  return "blue";
    case rgba_color_channel::alpha: return "alpha";
  }
}
```

The necessary repetition of the class enum name reduces legibility by
introducing noise in contexts where the enum class is obvious.

To eliminate the noise penalty for introducing long (but descriptive) `enum class`
names, this paper proposes that the statement

```cpp
using enum rgba_color_channel;
```

introduce the enum member identifiers into the local scope so that they may be referred to unqualified.

Furthermore, the syntax

```cpp
using rgba_color_channel::red;
```

should bring the identifier `red` into the local scope, so that it may be used
unqualified.

The above example would then probably be written as

```cpp
std::string_view to_string(rgba_color_channel channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```


Rationale {#rationale}
=========

Consistency {#consistency}
-----------

`enum class`es, as well as plain old `enum`s, are not classes - they seem to be
closer to namespaces consisting of `static constexpr` inline variables. The
familiar `using` syntax that works for namespaces should therefore apply to
them as well, in some fashion.


Better Identifiers {#betterids}
------------------

The introduction of this feature would allow better naming of enums. Currently,
enums are named with as short an identifier as possible, often to the point
of absurdity, when they are reduced to completely nondescriptive abbreviations
that only hint at their proper meaning (just what does `zfqc::add_op` mean?)

With this feature, identifiers become available to unqualified lookup in local
contexts where their source is obvious, giving control of lookup style back to
the user of the enum, instead of baking name semantics into the type of the
enum.


Evidence of Need {#need}
----------------
At a casual search, we were able to locate this
[thread on stackoverflow](https://stackoverflow.com/questions/9450338/equivalent-of-using-namespace-x-for-scoped-enumerations).

Anecdotally, 100% of people the authors have shown this to (~30) at CppCon have
displayed a very enthusiastic response, with frequent comments of "I'd use enum
classes but they are too verbose, this solves my problem!"


Proposal {#proposal}
========

Syntax: `using enum IDENTIFIER` {#using-enum-id}
-----------------------

We propose the addition of a new `using enum` statement:

```cpp
using enum IDENTIFIER;
```

The above statement introduces the members of the enumeration `IDENTIFIER` into
the local namespace, thus enabling lookup without qualification. As usual, a
name lookup ambiguity makes the program ill-formed (diagnostic required).


Syntax: `using ENUM_ID::IDENTIFIER` {#using-id}
---------------------------

We propose to allow the syntax of

```cpp
using ENUM_ID::IDENTIFIER
```

to introduce the `IDENTIFIER` into the local namespace, aliasing
`ENUM_ID::IDENTIFIER`.

This would mirror the current syntax for introducing namespaced names into the
current scope.

Note: this does not conflict with [[P0945R0]], because that paper only deals
with the syntax `using name = id-expression`, which duplicates the enumerator
name.


Frequently Asked Questions {#faq}
==========================

Can I do this with unscoped enums? {#faq-old-enum}
-----------------------------------

Yes. The motivation for that is the pattern

```cpp
class foo {
   enum bar {
     A,
     B,
     C
   };
};
```

which were superceeded by scoped enums. With this feature one can bring `A`,
`B` and `C` into the local scope by invoking:

```cpp
using enum foo::bar;
```


Are you proposing mirroring the namespace alias syntax as well? {#faq-ns-alias}
---------------------------------------------------------------

No. We already have a way to do that, and it looks like this:

```cpp
using my_alias = my::name_space::enum_name;
```

In addition, [[P0945R0]] proposes deprecating namespace aliases in favor of
generalized `using name = id_expression`, so doing this would go counter the
current movement of the standard.

Why not allow `using enum struct/class ENUM_ID;`? {#faq-using-enum-struct}
---------------------------------------------------

Because it's a needless complication and would introduce another layer of
"struct & class don't match" linter errors.


Why propose `using ENUM_ID::IDENTIFIER` at all? {#faq-using-decl-why}
-----------------------------------------------

... given that the following already works:

```cpp
  constexpr auto red = rgba_color_channel::red;
```

and that, given [[P0945R0]], this will work:
```cpp
  using red = rgba_color_channel::red;
```

The reason is "DRY" - don't repeat yourself. You're forced to repeat the name of
the enumerator. That said, the authors are perfectly willing to throw this part
of the paper out if the `using enum ENUM_ID` piece gets consensus and this is
the stumbling block.


Proposed Wording {#wording}
===========================

Preface {#wording-preface}
------------------
The authors are new at this, and welcome suggestions for wording.

The intention is to effectively mirror the wording for namespaces from
[namespace.udir], and pare it down to only things that apply to enumerators.

All wording is relative to the working draft of the ISO/IEC IS 14882: N4765.


Changes required to add `using enum IDENTIFIER;` {#wording-enumdirect}
----------------

In chapter [dcl.dcl], in [dcl.enum], add section titled "Using Directive", with
the stable reference "[enum.udir]".

Add:

<div class='ins'>
<i>using-enum-directive:</i><br>
<i>&nbsp;&nbsp;&nbsp;&nbsp;attribute-specifier-seq<sub>opt</sub></i>
<tt>using enum</tt> <i>nested-name-specifier<sub>opt</sub></i>
<i>enum-name</i>

1. A <i>using-enum-directive</i> shall not appear in class scope, but may appear in namespace scope or in block scope. The optional <i>attribute-specifier-seq</i> appertains to the <i>using-enum-directive</i>. The <i>enum-name</i> in a <i>using-enum-directive</i> shall name a scoped enumeration or an unscoped enumeration.

2. A <i>using-enum-directive</i> specifies that the <i>enumerator</i>s in the nominated scoped enumeration or unscoped enumeration can be used in the scope in which the <i>using-enum-directive</i> appears after the <i>using-enum-directive</i>.  During unqualified name lookup ([basic.lookup.unqual]), the names appear as if they were declared in the scope where the <i>using-enum-directive</i> appears.

3. A <i>using-enum-directive</i> does not add any members to the declarative region in which it appears. [ <i>Example:</i>
      ```cpp
      namespace A {
        enum class e { i = 0 };
        using enum a::e; // make e::i visible in A
        namespace B {
          enum class f { i = 1 };
          using enum A::B::f;
          void f1() {
            i;        // OK, A::B::f::i visible in B and hides A::e::i
          }
        }
      }
      namespace C {
        using enum A::e;
        using enum A::B::f;
        void f2() {
          i;        // ambiguous, A::e::i or A::B::f::i?
        }
      }

      ```
      &mdash; end example ]

</div>

Under [basic.def], add (just after <i>using-directive</i>)  (and renumber section):
<div class='ins'>
2.17. &mdash; it is a <i>using-enum-directive</i>

</div>

Changes required to add `using ENUM_ID::IDENTIFIER;` {#wording-enumdecl}
-------------------------

In chapter [namespace.udecl], remove:

<div class='del'>
7. A <i>using-declaration</i> shall not name a scoped enumerator.

</div>

Then add:
<div class='ins'>
7. A <i>using-declaration</i> that names a scoped enumerator shall become
       a synonim for that enumerator in the <i>using-declaration</i>'s
       declarative region. [ <i>Note:</i> this is equivalent to declaring that
       enumerator in the <i>using-declaration</i>'s declarative region. &mdash;
       <i>end note</i>]

</div>


Acknowledgements {#ack}
================

The authors would like to thank Marcel Ebmer and Lisa Lippincott for early
feedback, and the members of the BSI C++ WG for further feedback, especially
Graham Haynes and Barry Revzin.

<!--
 vim: ft=markdown wrap linebreak nolist textwidth=0 wrapmargin=0
-->
