<pre class='metadata'>
Title: Using Enum
Status: P
Audience: EWG, CWG
Editor: Gašper Ažman <gasper.azman@gmail.com>
Editor: Jonathan Müller <jonathan.mueller@foonathan.net>
Shortname: P1099
Abstract: Class enums are restricted namespaces. Let's extend the using declaration to them.
Group: WG21
Date: 2019-01-20
Markup Shorthands: markdown yes
Revision: 3
ED: https://github.com/atomgalaxy/using-enum/using-enum.bs
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

Revision History {#history}
================
- r1: Typos. Changed target from LEWG to EWG.
- r2: Added FAQ and wording, and extended to regular enums.
- r3: Added examples. Nothing of substance changed.
- r4: Clarified that `using enum enum_name` is supposed to have semantics as if the names were declared in the local scope as opposed to the way *using-directive* does it.

Motivation {#motivation}
==========

> The single biggest deterrent to use of scoped enumerations is the inability to associate them with a *using directive*.
>
> &nbsp;&nbsp;&nbsp;&nbsp;&mdash; Dan Saks

Consider an enum class:

```cpp
enum class rgba_color_channel { red, green, blue, alpha };
```

Currently, a switch using this enum looks as follows:

```cpp
std::string_view to_string(rgba_color_channel channel) {
  switch (channel) {
    case rgba_color_channel::red:   return "red";
    case rgba_color_channel::green: return "green";
    case rgba_color_channel::blue:  return "blue";
    case rgba_color_channel::alpha: return "alpha";
  }
}
```

The necessary repetition of the class enum name reduces legibility by introducing noise in contexts where the enum class is obvious.

To eliminate the noise penalty for introducing long (but descriptive) `enum class` names, this paper proposes that the statement

```cpp
using enum rgba_color_channel;
```

introduce the enum member identifiers into the local scope so that they may be referred to unqualified.

Furthermore, the syntax

```cpp
using rgba_color_channel::red;
```

should bring the identifier `red` into the local scope, so that it may be used unqualified.

The above example would then probably be written as

```cpp
std::string_view to_string(rgba_color_channel channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```


Rationale {#rationale}
=========

Consistency {#consistency}
-----------

`enum class`es, as well as plain old `enum`s, are not classes - they seem to be closer to namespaces consisting of `static constexpr` inline variables. The familiar `using` syntax that works for namespaces should therefore apply to them as well, in some fashion.


Better Identifiers {#betterids}
------------------

The introduction of this feature would allow better naming of enums. Currently, enums are named with as short an identifier as possible, often to the point of absurdity, when they are reduced to completely nondescriptive abbreviations that only hint at their proper meaning. (Just what does `zfqc::add_op` really mean?)

With this feature, identifiers become available to unqualified lookup in local contexts where their source is obvious, giving control of lookup style back to the user of the enum, instead of baking name semantics into the type of the enum.


Evidence of Need {#need}
----------------
At a casual search, we were able to locate this
[thread on stackoverflow](https://stackoverflow.com/questions/9450338/equivalent-of-using-namespace-x-for-scoped-enumerations).

Anecdotally, 100% of people the authors have shown this to (~30) at CppCon have displayed a very enthusiastic response, with frequent comments of "I'd use enum classes but they are too verbose, this solves my problem!"


Proposal {#proposal}
========

Syntax: `using ENUM_ID::IDENTIFIER` {#using-id}
---------------------------

We propose to allow the syntax of

```cpp
using ENUM_ID::IDENTIFIER
```

to introduce the `IDENTIFIER` into the local namespace, aliasing `ENUM_ID::IDENTIFIER`.

This would mirror the current syntax for introducing namespaced names into the current scope.

Note: this does not conflict with [[P0945R0]], because that paper only deals with the syntax `using name = id-expression`, which duplicates the enumerator name.


Syntax: `using enum IDENTIFIER` {#using-enum-id}
-----------------------

We propose the addition of a new `using enum` statement:

```cpp
using enum IDENTIFIER;
```

This makes all the enumerators of the enum available for lookup in the local scope. It's almost as if it expanded to a series of `using ENUM::ENUMERATOR` statements for every enumerator in the enum, but doesn't actually introduce any declarations into the local scope.

(Note: this was changed from "works as a using-directive" to the current way with a strong direction poll from EWG.)


Examples {#examples}
====================

Strongly typed enums with global identifiers {#strong-enums-global-ids}
-----------------------------------------------------------------------

This proposal lets you make strongly-typed enums still export their identifiers to namespace scope, therefore behaving like the old enums in that respect:

```
namespace my_lib {

enum class errcode {
  SUCCESS = 0,
  ENOMEM = 1,
  EAGAIN = 2,
  ETOOSLOW = 3
};
using enum errcode;

}

namespace foo {

my_lib::errcode get_widget() {
  using namespace my_lib;
  return ETOOSLOW; // works, and conversions to int don't.
}

}
```

Switching with no syntax overhead {#no-prefix-switches}
-------------------------------------------------------

The proposal allows for importing enums inside the switch body, which is a scope, and using them for labels:

```cpp
enum class rgba_color_channel { red, green, blue, alpha};

std::string_view to_string(rgba_color_channel channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```


Frequently Asked Questions {#faq}
==========================

Has this been implemented? {#faq-impl}
--------------------------------------

Yes. The author has an implementation in clang. It has not been reviewed or released yet, however. There do not seem to be major issues with implementation. In particular, the `using ENUM::IDENTIFIER` syntax literally entailed removing a condition from an if-statement, and that was it.


Can I do this with unscoped enums? {#faq-old-enum}
-----------------------------------

Yes. The motivation for that is the pattern

```cpp
class foo {
   enum bar {
     A,
     B,
     C
   };
};
```

which was superceeded by scoped enums. With the feature this paper proposes one can bring `A`, `B` and `C` into the local scope by invoking:

```cpp
using enum foo::bar;
```


Are you proposing mirroring the namespace alias syntax as well? {#faq-ns-alias}
-------------------------------------------------------------------------------

No. We already have a way to do that, and it looks like this:

```cpp
using my_alias = my::name_space::enum_name;
```

In addition, [[P0945R0]] proposes deprecating namespace aliases in favor of generalized `using name = id_expression`, so doing this would go counter the current movement of the standard.


Why not allow `using enum struct/class ENUM_ID;`? {#faq-using-enum-struct}
--------------------------------------------------------------------------

Because would have been a needless complication and would introduce another layer of "`struct` and `class` don't match" linter errors that current `class`es and `struct`s already have with forward declarations.


Why propose `using ENUM_ID::IDENTIFIER` at all? {#faq-using-decl-why}
---------------------------------------------------------------------

... given that the following already works:

```cpp
  constexpr auto red = rgba_color_channel::red;
```

and that, given [[P0945R0]], this will work:

```cpp
  using red = rgba_color_channel::red;
```

The reason is "DRY" - don't repeat yourself - one is forced to repeat the name of the enumerator. That said, the authors are perfectly willing to throw this part of the paper out if the `using enum ENUM_ID` piece gets consensus and this is the stumbling block.


Proposed Wording {#wording}
===========================

Preface {#wording-preface}
------------------
The authors are new at this, and welcome suggestions for wording.

The idea is that the identifiers appear as if they were declared in the declarative region where the using-enum-directive appears, and not model the using-directive's "enclosing namespace" wording.

All wording is relative to the working draft of the ISO/IEC IS 14882: N4765.


Changes required to add `using ENUM_ID::IDENTIFIER;` {#wording-enumdecl}
-------------------------

In chapter [namespace.udecl], remove:

<div class='del'>
7. A <i>using-declaration</i> shall not name a scoped enumerator.

</div>

Then add:
<div class='ins'>
7. A <i>using-declaration</i> that names a scoped or unscoped enumerator shall become a synonim for that enumerator in the <i>using-declaration</i>'s declarative region. [ <i>Note:</i> this is equivalent to declaring that enumerator in the <i>using-declaration</i>'s declarative region. &mdash; <i>end note</i>]

</div>


Changes required to add `using enum IDENTIFIER;` {#wording-enumdirect}
----------------

In chapter [dcl.dcl], in [dcl.enum], add section titled "Using Directive", with the stable reference "[enum.udir]".

Add:

<div class='ins'>
<i>using-enum-directive:</i><br>
<i>&nbsp;&nbsp;&nbsp;&nbsp;attribute-specifier-seq<sub>opt</sub></i>
<tt>using enum</tt> <i>nested-name-specifier<sub>opt</sub></i>
<i>enum-name</i>

1. A <i>using-enum-directive</i> shall not appear in class scope, but may appear in namespace scope or in block scope. The optional <i>attribute-specifier-seq</i> appertains to the <i>using-enum-directive</i>. The <i>enum-name</i> in a <i>using-enum-directive</i> shall name a scoped enumeration or an unscoped enumeration.

2. A <i>using-enum-directive</i> specifies that the <i>enumerator</i>s in the nominated scoped enumeration or unscoped enumeration can be used in the scope in which the <i>using-enum-directive</i> appears after the <i>using-enum-directive</i>.  During unqualified name lookup ([basic.lookup.unqual]), the names appear as if they were declared in the scope where the <i>using-enum-directive</i> appears.

3. A <i>using-enum-directive</i> does not add any members to the declarative region in which it appears.

</div>

Under [basic.def], add (just after <i>using-directive</i>)  (and renumber section):
<div class='ins'>
2.17. &mdash; it is a <i>using-enum-directive</i>

</div>


Acknowledgements {#ack}
================

The authors would like to thank Marcel Ebmer and Lisa Lippincott for early feedback, and the members of the BSI C++ WG for further feedback, especially Graham Haynes and Barry Revzin. Even further feedback was provided by Tomas Puverle, who encouraged us to extend it to `enum`s, and Dan Saks for the permission to include a quotation from him. A special thanks to Jeff Snyder who presented this to EWG.

<!--
 vim: ft=markdown wrap linebreak nolist textwidth=0 wrapmargin=0
-->
