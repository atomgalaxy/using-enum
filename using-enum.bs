<pre class='metadata'>
Title: Using Enum
Status: P
Audience: CWG
Editor: Gašper Ažman <gasper.azman@gmail.com>
Editor: Jonathan Müller <jonathan.mueller@nathan.net>
Shortname: P1099
Abstract: Class enums are restricted namespaces. Let's extend the using declaration to them.
Group: WG21
Date: 2019-03-10
Markup Shorthands: markdown yes
Revision: 4
ED: https://github.com/atomgalaxy/using-enum/using-enum.bs
</pre>

<style>
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: none;
}

.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
</style>

Revision History {#history}
================
- r1: Typos. Changed target from LEWG to EWG.
- r2: Added FAQ and wording, and extended to regular enums.
- r3: Added examples. Nothing of substance changed.
- r4: Clarified that `using enum enum_name` is supposed to have semantics as if the names were declared in the local scope as opposed to the way *using-directive* does it, as per EWG poll. Added Eric Niebler's example for using this feature to enable ADL-only functions on exposed enumerators (to support `std::begin` being a CPO). Added editorial notes for renaming the current Using Directive to Using Namespace Directive on Richard Smith's request.

Status of this paper {#status}
====================

This paper has been approved by EWG in Kona 2019 and sent to Core with the ship vehicle of C++20.


Motivation {#motivation}
==========

> The single biggest deterrent to use of scoped enumerations is the inability to associate them with a *using directive*.
>
> &nbsp;&nbsp;&nbsp;&nbsp;&mdash; Dan Saks

Consider an enum class:

```cpp
enum class rgba_color_channel { red, green, blue, alpha };
```

Currently, a switch using this enum looks as follows:

```cpp
std::string_view to_string(rgba_color_channel channel) {
  switch (channel) {
    case rgba_color_channel::red:   return "red";
    case rgba_color_channel::green: return "green";
    case rgba_color_channel::blue:  return "blue";
    case rgba_color_channel::alpha: return "alpha";
  }
}
```

The necessary repetition of the `enum class` name reduces legibility by introducing noise in contexts where said name is obvious.

To eliminate the noise penalty for introducing long (but descriptive) `enum class` names, this paper proposes that the statement

```cpp
using enum rgba_color_channel;
```

introduce the enumerator identifiers into the local scope, so they may be referred to unqualified.

Furthermore, the syntax

```cpp
using rgba_color_channel::red;
```

should bring the identifier `red` into the local scope, so it may be used unqualified.

The above example would then be written as

```cpp
std::string_view to_string(rgba_color_channel channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```


Rationale {#rationale}
=========

Consistency {#consistency}
-----------

`enum class`es and `enum`s are not classes - they are closer to namespaces comprising `static constexpr` inline variables. The familiar `using` syntax that works for namespaces should therefore apply to them as well, in some fashion. Because they are closed, small, and do not contain overload sets, we can do better than the *using-directive* does for namespaces, and actually get the identifiers into the local scope, which is what the user expects.


Better Identifiers {#betterids}
------------------

The introduction of this feature would allow better naming of enumerations. Currently, enums are named with as short an identifier as possible, often to the point of absurdity, when they are reduced to completely nondescriptive abbreviations that only hint at their proper meaning. (Just what does `zfqc::add_op` really mean?)

With this feature, identifiers become available to unqualified lookup in local contexts where their source is obvious, giving control of lookup style back to the user of the enum, instead of baking lookup semantics into the type of the enum.


Evidence of Need {#need}
----------------

At a casual search, we were able to locate this
[thread on stackoverflow](https://stackoverflow.com/questions/9450338/equivalent-of-using-namespace-x-for-scoped-enumerations).

Anecdotally, 100% of people the authors have shown this to (~30) at CppCon have displayed a very enthusiastic response, with frequent comments of "I'd use enum classes but they are too verbose, this solves my problem!"


Proposal {#proposal}
========

Syntax: `using ENUM_ID::IDENTIFIER` {#using-id}
---------------------------

We propose to allow the syntax of

```cpp
using ENUM_ID::IDENTIFIER
```

to introduce the `IDENTIFIER` into the local namespace, aliasing `ENUM_ID::IDENTIFIER`.

This would mirror the current syntax for introducing namespaced names into the current scope.

Note: this does not conflict with [[P0945R0]], because that paper only deals with the syntax `using name = id-expression`, which duplicates the enumerator name.


Syntax: `using enum IDENTIFIER` {#using-enum-id}
-----------------------

We propose the addition of a new `using enum` statement:

```cpp
using enum IDENTIFIER;
```

This makes all the enumerators of the enum available for lookup in the local scope. It's almost as if it expanded to a series of `using ENUM::ENUMERATOR` statements for every enumerator in the enum, but doesn't actually introduce any declarations into the local scope.

(Note: this was changed from "works as a using-directive" to the current way with a strong direction poll from EWG.)


Examples {#examples}
====================

Strongly typed enums with global identifiers {#strong-enums-global-ids}
-----------------------------------------------------------------------

This proposal lets you make strongly-typed enums still export their identifiers to namespace scope, therefore behaving like the old enums in that respect:

```
namespace my_lib {

enum class errcode {
  SUCCESS = 0,
  ENOMEM = 1,
  EAGAIN = 2,
  ETOOSLOW = 3
};
using enum errcode;

}

namespace  {

my_lib::errcode get_widget() {
  using namespace my_lib;
  return ETOOSLOW; // works, and conversions to int don't.
}

}
```

Switching with no syntax overhead {#no-prefix-switches}
-------------------------------------------------------

The proposal allows for importing enums inside the switch body, which is a scope, and using them for labels:

```cpp
enum class rgba_color_channel { red, green, blue, alpha};

std::string_view to_string(rgba_color_channel channel) {
  switch (my_channel) {
    using enum rgba_color_channel;
    case red:   return "red";
    case green: return "green";
    case blue:  return "blue";
    case alpha: return "alpha";
  }
}
```


Adding ADL-only Functions to Enumerations:
------------------------------------------

The proposal allows for adding ADL-only functions to enumerations without enumerators (supported now) and enumerators (currently not supported):

```cpp
namespace ns {
  struct E_detail {
    enum E {
      e1 
    };
    friend void swap(E&, E&);  // adl-only swap in the only associated scope of the enum
  };
  using E = E_detail::E;  // import E into ns
  using enum E;           // expose the enumerators of E in ns. Also note the direct reference to E.
}

int main() {
  auto x = ns::e1;
  auto y = ns::e2;
  swap(x, y); // finds the swap in the associated struct
}
```

This example was slightly modified from Eric Niebler's on the <i>lib</i> mailing list when trying to find a way to make `std::begin` and `std::end` CPOs in a backwards-compatible fashion.


Frequently Asked Questions {#faq}
==========================

Has this been implemented? {#faq-impl}
--------------------------------------

Yes. The author has an implementation in clang. It has not been reviewed or released yet, however. There do not seem to be major issues with implementation. In particular, the `using ENUM::IDENTIFIER` syntax literally entailed removing a condition from an if-statement, and that was it.


Can I do this with unscoped enums? {#faq-old-enum}
-----------------------------------

Yes. The motivation for that is the pattern

```cpp
class foo {
   enum bar {
     A,
     B,
     C
   };
};
```

which was superceeded by scoped enums. With the feature this paper proposes one can bring `A`, `B` and `C` into the local scope by invoking:

```cpp
using enum ::foo::bar;
```


Are you proposing mirroring the namespace alias syntax as well? {#faq-ns-alias}
-------------------------------------------------------------------------------

No. We already have a way to do that, and it looks like this:

```cpp
using my_alias = my::name_space::enum_name;
```

In addition, [[P0945R0]] proposes deprecating namespace aliases in favor of generalized `using name = id_expression`, so doing this would go counter the current movement of the standard.


Why not allow `using enum struct/class ENUM_ID;`? {#faq-using-enum-struct}
--------------------------------------------------------------------------

Because would have been a needless complication and would introduce another layer of "`struct` and `class` don't match" linter errors that current `class`es and `struct`s already have with forward declarations.


Why propose `using ENUM_ID::IDENTIFIER` at all? {#faq-using-decl-why}
---------------------------------------------------------------------

... given that the following already works:

```cpp
  constexpr auto red = rgba_color_channel::red;
```

and that, given [[P0945R0]], this will work:

```cpp
  using red = rgba_color_channel::red;
```

The reason is "DRY" - don't repeat yourself - one is forced to repeat the name of the enumerator. That said, the authors are perfectly willing to throw this part of the paper out if the `using enum ENUM_ID` piece gets consensus and this is the stumbling block.


Proposed Wording {#wording}
===========================

Preface {#wording-preface}
------------------

The idea is that the identifiers appear as if they were declared in the declarative region where the using-enum-directive appears, and not model the using-directive's "enclosing namespace" wording.

All wording is relative to the working draft of the ISO/IEC IS 14882: N4765, though, as it is almost entirely additive, it is also a valid diff to N8000.

Changes {#wording-changes}
-------------------------


In chapter [namespace.udecl]:

3. In a <i>using-declaration</i> used as a <i>member-declaration</i>, each <i>using-declarator</i><del>'s</del> <ins>shall either name an enumerator or have a</ins> <i>nested-name-specifier</i> <del>shall name</del> <ins>naming</ins> a base class of the class being defined. <ins>[Note: this exception allows the introduction of enumerators into class scope. --end note]</ins>

<del>7. A <i>using-declaration</i> shall not name a scoped enumerator.</del>

8. A <i>using-declaration</i> that names a class member <ins>that is not an enumerator</ins> shall be a <i>member-declaration</i>. <ins>[Note: the exception for enumerators allows the introduction of class members that are enumerators into non-class scope --end note]</ins>


In chapter [dcl.dcl], in [dcl.enum], add section titled "Using Enum Directive", with the stable reference "[enum.udir]".

<div class='ins'>
<i>using-enum-directive:</i><br>
<i>&nbsp;&nbsp;&nbsp;&nbsp;attribute-specifier-seq<sub>opt</sub></i>
<tt>using </tt> <i>elaborated-type-specifier</i>;

1. The <i>elaborated-type-specifier</i> shall name an enumeration. [Note: an elaborated type specifier for an enumeration always begins with `enum` -- end note]
2. The <i>elaborated-type-specifier</i> shall not name a dependent type.
2. The optional <i>attribute-specifier-seq</i> appertains to the <i>using-enum-directive</i>.
3. A <i>using-enum-directive</i> introduces the enumerator names of the named enumeration into the scope in which it appears, as synonyms for the enumerators of the named enumeration. [Note: this means that they may be used, qualified or unqualified, after the <i>using-enum-directive</i> -- end note]

[Note: an <i>using-enum-directive</i> in class scope adds the enumerators of the named enumeration as members to the scope. This means they are accessible for member lookup. Example:
```
enum class E { e1, e2 };
struct S {
  using enum E; // introduces e1 and e2 into S
};
void f() {
  S s;
  s.e1; // well-formed, names E::e1.
  S::e2; // well-formed, names E::e2.
}
```
-- end note]

</div>

Under [basic.def], add (just after <i>using-directive</i>)  (and renumber section):
<div class='ins'>
2.17. &mdash; it is a <i>using-enum-directive</i>

</div>

In [gram.dcl], under <i>block-declaration</i>:

<i>block-declaration</i><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[...]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<i>using-directive</i><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<ins><i>using-enum-directive</i></ins><br/>

In [class.mem], under <i>member-declaration</i>:

<i>member-declaration</i><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[...]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<i>using-declaration</i><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<ins><i>using-enum-directive</i></ins><br/>


Note to editor:

For greater consistency, rename, everywhere:
- "using directive" to "using namespace directive"
- and "<i>using-directive</i>" to "<i>using-namespace-directive</i>"
- [namespace.udir]'s title should be Using Namespace Directive.


Acknowledgements {#ack}
================

The authors would like to thank Marcel Ebmer and Lisa Lippincott for early feedback, and the members of the BSI C++ WG for further feedback, especially Graham Haynes and Barry Revzin. Even further feedback was provided by Tomas Puverle, who encouraged us to extend it to `enum`s, and Dan Saks for the permission to include a quotation from him. A special thanks to Jeff Snyder who presented this to EWG, and to Richard Smith for pointing out direct injection is really the better way to go. Casey Carter pointed out some issues with wording typography, and realized that this paper allows adding adl-only functions to enumerators.

Another big thank-you to the Wizard of Worde, Richard Smith, who helped with the final wording, and found the need to make enum names non-dependent.

<!--
 vim: ft=markdown wrap linebreak nolist textwidth=0 wrapmargin=0
-->
